title: cookie_and_session
date: 2014-12-13 16:21:10
categories: go
tags: web
---
最近，公司正在转型中，所以日常需求就很少；我就有大量的时间来学习自己感兴趣东西；最近给自己定下来两个感兴趣的点，一个是go，一个是redis，为什么要选择这两个呢，也好多人问我这个问题，其实我觉得比较符合我写代码的习惯吧，redis是C，go中有C的影子，让我多少感觉有点亲切感；而且我想与其花大量时间去学习Java，这么大众的语言，成本略高，我学习一个比较新的，还比较小众的语言也是有优势的哇.反正最近就在学习这两个东西；光是学习肯定也没有用，所以最近准备去阿里云弄一个VPS来搭建一个go的web框架，然后结合redis来做一些实验性的东西。

在学习go语言的过程中，对session和cookie这两个陌生的概念进行总结；包括一些关于cookie的攻击，比如xss、csrf等攻击，以及为什么我们要不相信用户的输入，要对输入输出数据进行过滤处理，下面我就开始我的文章吧。

### 1. cookie和session
cookie：保存在客户端这边的，用来保存各个网站的一些信息；这些信息是服务器主动要求客户端进行保存的；当我们访问某一个指定的网站的时候，Brower就会把对应的cookie传送给服务器。

session：是服务器为了保持每一个用户状态而存在的；从服务器角度上来说，它必须知道当前用户是谁，才能知道这个用户上次来我们服务器的状态，而session从本质上来说就是服务器为了识别用户而存在的数据。举一个比较老套的例子，购物车，你在这个网页往购物车中添加了超多的商品，但是由于HTTP的无状态性，当你下次访问这个页面的时候，服务器根本就不知道是你(除非你登陆)，那你的购物车里面就是空的。所以服务器为了不让用户每到一个网页就登陆一次，就通过session来保存用户的一种状态.

服务器这边一边保存信息是没有用的，还要用户能主动的告诉服务器它是谁；所以这个时候就要用上cookie了，服务器在返回response的时候往用户的cookie里面设置一个sessionId，这个sessionId对于服务器来说是唯一的，所以服务器能判断是那个用户来访问了.

##### 1.1 request和response

![cookie](http://7j1wkc.com1.z0.glb.clouddn.com/tmp_1-3.png)

##### 1.2 session和cookie的工作流程图

![工作流程图](http://frgeek-bed.qiniudn.com/tmp_session_cookie.png)

##### 1.3 注意点

	1. 每一次发送给服务器的cookie是会进行选择的；主要的参数来源于cookie中的domain和path，domain限定域名，而path限定路径；只要作用范围大于规定的服务端的作用范围，那么这个cookie就会被发送给指定的服务器；
	2. cookie两种，一种是会话性cookie，一种是存储性的cookie；会话性的cookie当生命周期依赖于Brower，而存储型的cookie会存放到硬盘上去的.
	
### 2. 流行的攻击方法

##### 2.1 XSS

> XSS:cross-site scripting:跨站脚本攻击；在网上看到一文章，里面的解释了Xss的本质就是:在HTML页面中注入恶意代码;通常的xss有两种攻击方法：反射性和存储型；

###### 2.1.1 反射型

	A:攻击方 B:服务器 C:受害者的client
	
	1. A给C发送一个连接,url="www.baidu.com?search=<script>alert(document.cookie)</script>"
	2. B服务器搜到这个请求以后就把与<script>alert(document.cookie)</script>相关的内容返回给C，通常会把"<script>alert(document.cookie)</script>"这个也返回给C；这个时候返回的网页就是嵌入了而恶意代码的html
	3. C的Brower会运行这个脚本，这个时候会弹出一个窗口显示着你的cookie信息;
	
	这个就是具体的过程；通过服务器反射恶意代码给用户，导致用户的cookie信息被窃取;所以不要乱点击可疑的url;
	
###### 2.1.2 存储型 

	A:攻击方 B:服务器 C:受害者的client

	存储型攻击对于反射型攻击的区别在于，反射型攻击是一次性的，非持久化的，都是要通过用户点击才能触发的，但是存储型攻击在于恶意代码会被存放在服务器的存储机制中，比如DB，持久化的。具体的例子就是哪些能让用户输入数据的网站，比如论坛的评价，如果用户在评论框中输入恶意代码，这个代码会被存放到DB中，以后只要用户点击这个帖子就会被恶意代码攻击.

##### 2.2 CSRF

> CSRF:cross-site request forgery（跨站请求伪造）;

基本场景为:当你刚刚登陆银行，这个时候你打开了另外一个网页，这个网页中可能有一个链接，这个链接可能就是银行网站的url，这个时候你的brower就会触发去请求银行，因为是你的brower触发的，所以会带有你的cookie去访问银行网站，这个时候他就具有你一样的权限，如果银行的转账是用low的参数触发，那么就可能会直接导致你的钱转到别人的账号，而你不知道...

### 3. 对于这些，我们能做什么

从上面的攻击方式可以看出，cookie还是相当的隐私重要的，除了让客户自己注意安全，养成比较靠谱的习惯，最为主要的服务器这端我们能做些什么呢？

针对XSS的攻击就是往网页中嵌入恶意代码，所以在服务器这段，必须对用户的输入采取不信任的态度，对所有用户的输入都进行过滤和处理，比如go语言的处理函数为:

	func HTMLEscape(w io.Writer, b []byte)
	func HTMLEscapeString(s string) string
	func HTMLEscaper(args …interface{}) string

这些函数都可以对用户输入进行适当的处理， 把一些敏感的符号进行转义，这样就防止脚本注入了;除了上面的处理，我们对我们需要的数据也进行适配处理，比如我们需要的是一个数字那就进行匹配;

针对csrf的攻击，这个通常是攻击方伪造用户来请求数据，这个时候我能做的有以下这些：

	1. 把GET与POST进行分离，如果要更新数据的就使用POST，而查看使用GET，这样就可以防止大部分csrf；
	2. 给非GET方法加入随机token这个参数；其实很简单，csrf实质就是攻击方让你的浏览器给规定的url发出请求，而这个请求是带着cookie信息的；但是如果我们在页面中加入token数据，但是这个数据不存在cookie中，那么当攻击方的url发出请求以后就不会知道token信息，那么服务端就知道这个请求是不合法的；
	
### 4. 总结

对cookie和session的总结就如上这些；从攻击方的实施方法，我们服务端采取适当的方法就可以避免很多的攻击，为什么介绍这些呢，我希望自己能知道为什么我们要这么做，而不是简单的只是去照着书本去做...




	



	
