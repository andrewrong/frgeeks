title: redis持久化(详细描述)
date: 2014-11-04 17:55:28
categories:
tags:
---

### 1. 关于AOF和RDB两种持久化机制的优缺点比较

在前面一篇文章中，对AOF和RDB持久化机制进行了简单的介绍；总结起来就是RDB是把数据库所有的数据dump到本地，而AOF则是保存了所有写redis的命令到AOF文件中。对于这两种持久化的优缺点如下：

1.1 RDB优点和缺点

    1. rdb文件比较紧凑，非常适合用来当做备份使用;
    2. rdb恢复的速度比AOF快，原因就是因为RDB是对数据库的备份，恢复就是直接在copy到内存中去;

    1. rdb持久化比较消耗性能，因为每一次调用bgsave和save命令的时候都会大量写文件;
    2. 持久化粒度太粗，原因和上一样，性能决定了它不能频繁调用;
    
1.2 AOF优点和缺点

    1. 对数据保护性更加高；
    2. 写入量小,因为仅仅只是追加写命令到AOF文件中去
    3. 当AOF过大的时候，可以通过rewrite来减少AOF文件的大小;
    4. 从持久化的角度上来说，它比RDB更加适合;

    1. AOF文件比RDB大
    2. 从恢复的速度来说，AOF没有RDB快;

如何选择RDB和AOF呢，我觉得如果你比较关心数据本身，并且是分秒必争的话，那就AOF持久化更加适合你；如果不是这样的话RDB也很不错的，而且RDB很适合做数据备份，就和MAC的time machine一样。

### 2. RDB的实现原理

首先，RDB持久化的本质就是将数据库中的所有内容dump到磁盘上的文件(dump.rdb);其中最主要关心的是如何保证性能的情况下把那么多的数据dump到文件中。先看看dump的过程会遇到什么样的问题：

1. 通常redis服务器的数据量都是很大的，那就表示如果要把那么多数据dump到磁盘中，调用write就会阻塞进程本身；而redis server处理client的命令是通过维护一个有序的队列，并且其一个单进程去处理这些命令，从这个逻辑上讲，当主进程被写操作阻塞的时候，redis server就没有办法处理其他的client的命令;
2. dump的文件一定是某一个时刻的数据库内容，而不是一种持续变化的内容;

对于上面两个问题，redis通过创建子进程的方式来进行处理，基本的过程如下:

1. 使用fork创建子进程;
2. 子进程调用rdbSave进行rdb文件的写入;
3. 父进程这个时候做两件事情，第一件就是处理各个client端的命令，所有的操作都源于内存，所以子进程的操作不影响处理client的命令；第二件事情就是监听子进程的状态，看这次save是否已经结束;

redis中可以出发RDB持久化的有两个命令，save和bgsave，区别是save是在主进程中直接dump文件，而bgsave就是创建一个子进程来dump文件。就如下面伪代码所显示的一样的；在redis中dump文件的具体函数是rdbSave这个函数，具体的是怎么操作来实现数据库的dump呢，基本思路就是遍历redis server中所有的数据库，把所有key-value字段全部写入到rdb文件中；具体实现在redis的src目录下面的rdb.c/rdbSave。创建子进程不但解决了第一个问题，也解决了第二个问题；这个问题的解决主要依赖于Linux对fork的实现-copy on write。下面显示伪代码和具体的流程图。

```
    int save(){
        rdbSave();//由于要进行大量的io操作，文件的读写，所以这个时候进程就阻塞在这里;
    }
    
    int bgsave(){
        int pid = fork();
    
        if(pid > 0){
	   //父进程
	   handle_request_and_wait_signal();//处理客户端的请求并且等待子进程结束
        }else if(pid == 0){
	   //子进程
	   rdbSave();//这样子进程就专心就写文件，而主进程专心处理客户端请求
	   signal_parent();//如果处理完毕就通知父进程;
        }
    }

```

![rdb流程图](http://frgeek-bed.qiniudn.com/tmp_rdb.png)



### 3. AOF的实现原理

AOF文件本质就是把所有操作redis服务器的写操作的命令全部保存到aof文件中去，这个与数据库中的binlog很相似，通过设置不同的配置基本上可以保证redis的数据安全能做到和数据库差不多；AOF持久化的操作流程如图：

![aof流程图](http://frgeek-bed.qiniudn.com/tmp_aof.png) 

AOF文件遇到的问题和binlog遇到的问题是很类似的，当redis运行时间越长，AOF文件就会越加的庞大，如果不对其进行处理的后果就是下次redis崩溃，那么恢复就是一个很漫长的时间，因为要一条条的记录重新执行一遍；这也是上面我们对RDB持久化的优点，rdb文件比较紧凑，恢复速度比AOF文件快很多。那么如何处理这个问题呢，其实也和binlog差不多，当AOF文件达到一定程度以后就会自动进行rewrite机制。

rewrite(重写)机制，就是对AOF文件进行重写。为什么可以进行重写呢？因为对一个数据进行过多次的操作，在AOF文件中可能保存了多条命令，但是可能这个值就没有变化，那么我们就可以整合这样的记录，在redis中的重写，其实不会对AOF文件的分析，因为基于数据库当前的状态进行通过set命令一个一个进行的，这样的操作以后是AOF的体积大大减小，但是功能基本和之前的AOF文件一样。

这里要提到AOF文件的那个比较关键的问题，一个是AOF文件写入的过程，二是AOF文件重写的实现，已经中间的一些问题。我们都知道调用write系统调用本身不会直接把内容写到磁盘中去，通常os会自己根据缓存的大小或者人员手手动的操作去把缓存中的内容刷新到磁盘中去，如果redis依靠操作系统的刷入的话，那么就可能会导致redis数据不安全，于是redis就出现了对AOF持久化的三种配置,分别为
    
    always:每一次写入都刷新到磁盘中，最安全，但是性能比较低;
    everysec:每隔一秒写入到磁盘,redis默认使用，对此进行过优化，性能很好;
    no:依赖于操作系统，性能很好但是不安全;

对于重写的机制实现基本和RDB形式基本类似，主要的步骤如下：

    1. 当服务器接受到bgrewriteaof命令
    2. fork一个子进程
	2.1 父进程处理client命令，监听子进程的状态；
	2.2 子进程通过rewriteAppendOnlyFileBackground函数进行重写
	    2.2.1 创建临时的AOF文件
	    2.2.2 遍历数据库把命令写入到aof文件
	    2.2.3 把信号返回给主进程，告诉主进程我已经重写好了;
	2.3 将主进程中的aof文件缓存中的数据与临时的aof文件合并
	2.4 主进程原子性的把rename到新的aof文件上去
    3. rewrite结束

![rewrite](http://frgeek-bed.qiniudn.com/tmp_rewrite.png)

上面这个图很好的描述了rewrite的机制；通过子进程的模式，可以保证主进程能安心处理客户端处理，只有merge和rename才会阻塞主进程。从图中可以看到有一个merge的过程，为什么有这样的一个过程？让我们来考虑这么一个问题，当创建子进程以后重写过程中，主进程还是能接受client命令，这就表示数据库与子进程重写的数据库是不一致的，那就表示重写以后的aof与当前状态是不一致的。而redis的处理机制就是主进程在记录到aof文件的同时还是记录到aof缓存区，当子进程结束以后在进行合并，就可以达到一致性了。而且在merge和rename的时候会阻塞主进程，那么保证在这个期间是不可能接受client命令。

这里有一个疑问，为什么主进程修改了数据库，但是为什么子进程的数据库是不会被改变呢？这个源于Linux的fork的具体实现，理论上来说，当fork被调用的，子进程基本上是copy父进程的数据段、堆栈，但是代码段是共享的，但是由于子进程通常都是fork+exec去运行其他的程序，所以copy本身很浪费性能；于是出现了copy on write,当子进程创建出来以后，子进程中数据段、代码段、堆栈都是指向父进程的物理空间，子进程的虚拟地址虽然不一样，但是物理空间其实是一样的。在数据段被修改之前，数据段是只读的，但是数据段被改变的时候，os才会把数据段copy出来，然后进行修改。对应于上面的问题，当父进程把数据库给修改了以后，系统就会copy一份数据段给子进程，这个时候子进程的数据库与父进程的数据段是不一样的，这就是上面的问题解答。

### 4. 总结

上面基本上是对redis持久化的介绍，没有涉及到具体的代码，但是基本的原理差不多，懂了原理看代码就会好很多哇。
